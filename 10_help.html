<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adatbázis oracle</title>
</head>
<body>
    9.1. Soros és sorba rendezhető ütemezések
A konkurenciavezérlés tanulmányozását azzal kezdjük, hogy megvizsgáljuk, a konkurensen végrehajtott tranzakciók milyen feltételekkel tudják megőrizni az adatbázis-állapot konzisztenciáját. Az alapfeltevésünk, amelyet „helyességi elv”-nek (correctness principle) neveztünk, a 8.1.3. részben az volt, hogy ha minden egyes tranzakciót elkülönítve hajtunk végre (anélkül, hogy más tranzakció konkurensen futna), akkor az adatbázist konzisztens állapotból konzisztens állapotba alakítjuk. A gyakorlatban azonban a tranzakciók általában más tranzakciókkal egyidejűleg konkurensen futnak, emiatt a helyességi elvet közvetlenül nem alkalmazhatjuk. Így olyan „ütemezéseket” kell tekintenünk, amelyek biztosítják, hogy ugyanazt az eredményt állítják elő, mintha a tranzakciókat egyesével hajtottuk volna végre. Az egész fejezet fő témáját adják azok a módszerek, amelyek biztosítják, hogy a tranzakciók csak olyan módon legyenek konkurensen végrehajtva, mintha sorban egyesével futottak volna le.
9.1.1. Ütemezések
Az ütemezés (schedule) egy vagy több tranzakció által végrehajtott lényeges műveletek időrendben vett sorozata. Amikor a konkurenciavezérlést tanulmányozzuk, a lényeges olvasási és írási műveletek a központi memória puffereiben történnek, nem pedig lemezen. Vagyis egy A adatbáziselemet, amelyet valamelyik T tranzakció hozott be a pufferbe, ebben a pufferben nemcsak a T tudja olvasni vagy írni, hanem más tranzakciók is hozzáférhetnek az A-hoz. Idézzük fel a 8.1.4. részből, hogy a READ (OLVASÁS) és a WRITE (ÍRÁS) műveletek először meghívnak egy INPUT utasítást, hogy az adatbáziselemet a lemezről betöltsék, ha még nincs a pufferben, egyébként pedig a READ és WRITE műveletek közvetlenül a pufferben hozzáférnek az elemhez. Ezért csupán a READ és WRITE műveletek és a sorrendjük számít, amikor a konkurenciával foglalkozunk, és az INPUT, illetve OUTPUT műveleteket figyelmen kívül fogjuk hagyni.
9.1. példa: Tekintsünk két tranzakciót és az adatbázison való hatásukat, amikor egy meghatározott sorrendben hajtjuk végre a műveleteiket. A T1 és T2 tranzakciók fő műveletei a 9.2. ábrán találhatók. A t és s változók a T1-nek, illetve T2-nek megfelelő helyi változók, és nem adatbáziselemek.
T1	T2
READ(A,t)	READ(A,s)
t := t+100	s := s*2
WRITE(A,t)	WRITE(A,s)
READ(B,t)	READ(B,s)
t := t+100	s := s*2
WRITE(B,t)	WRITE(B,s)
9.2. ábra. Két tranzakció
Tételezzük fel, hogy az adatbázis-állapoton az egyetlen konzisztencia megszorítás az A = B. Mivel a T1 az A-hoz és a B-hez is hozzáad 100-at, és a T2 az A-t és a B-t is megszorozza 2-vel, tudjuk, hogy az egyes tranzakciók, egymástól elkülönítve futva megőrzik a konzisztenciát. 

T1	T2	A	B
		125	125
READ(A,t)			
t := t+100			
WRITE(A,t)		125	
READ(B,t)			
t := t+100			
WRITE(B,t)			125
	READ(A,s)		
	s := s*2		
	WRITE(A,s)	250	
	READ(B,s)		
	s := s*2		
	WRITE(B,s)		250
9.3. ábra. Soros ütemezés, amelyben T1 megelőzi T2-t
9.1.2. Soros ütemezések
Azt mondjuk, hogy egy ütemezés soros (serial schedule), ha úgy épül fel a tranzakciós műveletekből, hogy először az egyik tranzakció összes műveletét tartalmazza, majd azután egy másik tranzakció összes műveletét stb., miközben nem cseréli fel a műveleteket. Pontosabban kifejezve, egy S ütemezés soros, ha bármely két T és T tranzakcióra, ha T-nek van olyan művelete, amely megelőzi a T valamelyik műveletét, akkor a T összes művelete megelőzi a T valamennyi műveletét.
9.2. példa: A 9.2. ábrán szereplő tranzakcióknak két soros ütemezése van, az egyikben T1 megelőzi T2-t, a másikban T2 előzi meg T1-et. A 9.3. ábra azt az eseménysorozatot mutatja, amikor T1 megelőzi T2-t, és a kezdeti állapot A = B = 25. Azt a megállapodást követjük, hogy időrendi sorrendben függőlegesen lefelé írunk. Továbbá a megjelenített A és B értékek a központi memória pufferbeli értékeire utalnak, nem szükségképpen a lemezen tárolt értékeire.
A 9.4. ábrán látjuk a másik soros ütemezést, amelyben T2 megelőzi T1-et. A kezdeti állapot legyen megint A = B = 25. Megjegyezzük, hogy A és B végső értéke különböző a két ütemezésben, mégpedig mindkettő értéke 250, ha a T1 fut először, és 150, ha a T2 fut előbb. De nem is a végeredmény a központi kérdés addig, amíg a konzisztenciát megőrizzük. Általában nem várjuk el, hogy az adatbázis végső állapota független legyen a tranzakciók sorrendjétől. 

T1	T2	A	B
		125	125
	READ(A,s)		
	s := s*2		
	WRITE(A,s)	150	
	READ(B,s)		
	s := s*2		
	WRITE(B,s)		150
READ(A,t)			
t := t+100			
WRITE(A,t)		150	
READ(B,t)			
t := t+100			
WRITE(B,t)			150
9.4. ábra. Soros ütemezés, amelyben T2 megelőzi T1-t

A soros ütemezést úgy ábrázolhatjuk, mint ahogyan a 9.3. ábrán vagy a 9.4. ábrán látható, a műveleteket az előfordulásuk sorrendjében soroljuk fel. Másrészt, mivel a soros ütemezésben a műveletek sorrendje csak magától a tranzakciók sorrendjétől függ, ezért a soros ütemezést néha a tranzakciók felsorolásával fogjuk megadni. Így a 9.3. ábra ütemezését (T1, T2) reprezentálja, a 9.4. ábráét pedig (T2, T1).
9.1.3. Sorba rendezhető ütemezések
A tranzakciókra vonatkozó helyességi elv szerint minden soros ütemezés megőrzi az adatbázis-állapot konzisztenciáját. Vajon van-e más ütemezés is, amely szintén biztosítja a konzisztencia megmaradását? Igen, ilyen létezik, ahogyan ezt a következő példa mutatja. Általában azt mondjuk, hogy egy ütemezés sorba rendezhető (serializable schedule), ha ugyanolyan hatással van az adatbázis állapotára, mint valamelyik soros ütemezés, függetlenül attól, hogy mi volt az adatbázis kezdeti állapota.
9.3. példa: A 9.5. ábrán látjuk a 9.1. példában szereplő két tranzakciónak egy sorba rendezhető, ám nem soros ütemezését. Ebben az ütemezésben T2 azután van hatással az A-ra, miután a T1 volt, de mielőtt a T1 hatással lenne a B-re. Mégis azt látjuk, hogy ebben az ütemezésben a két tranzakció hatása megegyezik a 9.3. ábrán látható (T1, T2) soros ütemezés hatásával. Ahhoz, hogy meggyőződjünk az állítás igazságáról, nemcsak azt az esetet kell megnéznünk, amely a 9.5. ábrán látható, amikor az adatbázis-állapot A = B = 25-ről indul, hanem bármely konzisztens adatbázis kiindulási állapotból kiindulva. Mivel minden konzisztens adatbázis-állapotban az A = B = c valamely c konstanssal, nem nehéz levezetnünk, hogy a 9.5. ábra ütemezésében az A-nak is és a B-nek is 2(c + 100) lesz az értéke, és így bármelyik konzisztens állapotból indulunk ki, a konzisztenciát megőrizzük.

T1	T2	A	B
		125	125
READ(A,t)			
t := t+100			
WRITE(A,t)		125	
	READ(A,s)		
	s := s*2		
	WRITE(A,s)	250	
READ(B,t)			
t := t+100			
WRITE(B,t)			125
	READ(B,s)		
	s := s*2		
	WRITE(B,s)		250
9.5. ábra. Sorba rendezhető, de nem soros ütemezés
T1	T2	A	B
		125	125
READ(A,t)			
t := t+100			
WRITE(A,t)		125	
	READ(A,s)		
	s := s*2		
	WRITE(A,s)	250	
	READ(B,s)		
	s := s*2		
	WRITE(B,s)		150
READ(B,t)			
t := t+100			
WRITE(B,t)			150
9.6. ábra. Nem sorba rendezhető ütemezés
Másrészt tekintsük a 9.6. ábrán található ütemezést. Világos, hogy ez nem soros, de ami lényegesebb, nem is sorba rendezhető. Meggyőződhetünk arról, hogy nem sorba rendezhető, ugyanis legyen a kiindulási konzisztens állapotban A = B = 25, és az adatbázis inkonzisztens állapotba kerül, amikor A = 250 és B = 150 lesz. Megjegyezzük, hogy ebben a műveleti sorrendben, a T1 dolgozik előbb az A-val, viszont T2 dolgozik előbb a B-vel, ennek hatásaként másképpen kell kiszámolnunk A-t és B-t, vagyis A := 2(A + 100), szemben B := 2B + 100-zal. A 9.6. ábrán található ütemezés olyan viselkedést mutat, amelyet a konkurenciavezérlési működésekkel el kell kerülnünk. 
9.1.4. A tranzakció szemantikájának hatása
A sorbarendezhetőségi vizsgálatainkban eddig a tranzakciók által végrehajtott műveleteket néztük meg részletesen annak érdekében, hogy meghatározzuk sorbarendezhető-e az ütemezés. Azonban a tranzakciók részletei is számítanak, ahogyan ezt a következő példából láthatjuk.
9.4. példa: Tekintsük a 9.7. ábrán látható ütemezést, amely csak a T2 által végrehajtott számításokban különbözik a 9.6. ábrától, mégpedig abban, hogy a T2 nem 2-vel szorozza meg A-t és B-t, hanem 1-gyel.  Ekkor A és B értéke az ütemezés végén megegyezik, és könnyen ellenőrizhetjük, hogy a konzisztens kezdeti állapottól függetlenül a végállapot is konzisztens lesz. Valójában az egyetlen végállapot az, amelyet vagy a (T1, T2) vagy a (T2, T1) soros ütemezés eredményez. 


T1	T2	A	B
		125	125
READ(A,t)			
t := t+100			
WRITE(A,t)		125	
	READ(A,s)		
	s := s*1		
	WRITE(A,s)	125	
	READ(B,s)		
	s := s*1		
	WRITE(B,s)		125
READ(B,t)			
t := t+100			
WRITE(B,t)			125
9.7. ábra. Egy olyan ütemezés, amely csak a tranzakciók
részletezett viselkedése miatt sorba rendezhető
Sajnos, az ütemező számára nem reális a tranzakciós számítások részleteinek figyelembevétele. Mivel a tranzakciók gyakran tartalmaznak általános célú programozási nyelven írt kódokat éppúgy, mint SQL vagy más magas szintű nyelv utasításait, néha nagyon nehéz megválaszolni azokat a kérdéseket, mint pl. „ez a tranzakció az A-t egy 1-től különböző konstanssal szorozta-e meg?”. Az ütemezőnek azonban látnia kell a tranzakciók olvasási és írási kéréseit, így tudhatja, hogy az egyes tranzakciók mely adatbáziselemeket olvasták be, és mely elemek változhattak meg. Az ütemező feladatának az egyszerűsítésére megszokott az a feltételezés, hogy:
•	Bármely A adatbáziselemnek egy T tranzakció olyan értéket ír be, amely az adatbázis-állapottól függ oly 
módon, hogy ne forduljon elő aritmetikai egybeesés.
Más szóval kifejezve, ha a T tudna az A-ra olyan hatással lenni, hogy az adatbázis-állapot inkonzisztenssé váljék, akkor a T ezt meg is teszi. Ezt a feltevést a 9.2. részben pontosítjuk, amikor a sorbarendezhetőség biztosítására adunk meg elégséges feltételeket.
9.1.5. A tranzakciók és ütemezések jelölése
Ha elfogadjuk, hogy egy tranzakció által végrehajtott pontos számítások tetszőlegesek lehetnek, akkor nem szükséges a helyi számítási lépések részleteit néznünk, mint amilyen a t := t+100. Csak a tranzakciók által végrehajtott olvasások és írások számítanak. Így a tranzakciókat és az ütemezéseket rövidebben jelölhetjük. Ekkor rT(X) és wT(X) tranzakció műveletek, és azt jelentik, hogy a T tranzakció olvassa (r, az angol read = olvasás rövidítése), illetve írja (w, az angol write = írás rövidítése) az X adatbáziselemet. Továbbá, mivel a tranzakcióinkat T1, T2, …-vel fogjuk általában jelölni, így megállapodunk abban, hogy ri(X) és wi(X) ugyanazt jelöli, mint rTi(X), illetve wTi(X).
9.5. példa: A 9.2. ábrán látható tranzakciók az alábbi módon írhatók fel:
T1: r1(A); w1(A); r1(B); w1(B);
T2: r2(A); w2(A); r2(B); w2(B);
Megjegyezzük, hogy nem említettük sehol a t és az s helyi változókat, és nem jelöltük azt sem, hogy mi történt a beolvasás után az A-val és B-vel. Intuíció alapján ezt úgy értelmezzük, hogy az adatbáziselemek megváltozásában a „legrosszabbat fogjuk feltételezni”.
Egy másik példaként nézzük meg a T1 és T2-nek a 9.5. ábrán látható sorba rendezhető ütemezését. Ezt az ütemezést átírva:
r1(A); w1(A); r2(A); w2(A); r1(B); w1(B); r2(B); w2(B);

Pontosítva a jelölést:
1.	Egy tranzakció műveletét (action of transaction) ri(X) vagy wi(X) formában fejezünk ki, amely azt jelenti, hogy a Ti tranzakció olvassa (read), illetve írja (write) az X adatbáziselemet.
2.	Egy Ti tranzakció az i indexű műveletekből álló sorozat.
3.	A T tranzakciók halmazának egy S ütemezése olyan műveletek sorozata, amelyben minden T halmazbeli Ti tranzakcióra teljesül, hogy Ti műveletei ugyanabban a sorrendben fordulnak elő az S-ben, mint ahogy magában a Ti definíciójában szerepeltek. Azt mondjuk, hogy az S az őt alkotó tranzakciók műveleteinek átlapolása (interleaving).

Például a 9.5. példában található ütemezésben az összes 1-es indexű művelet ugyanabban a sorrendben szerepel, mint ahogy a T1 definíciójában volt, és az összes 2-es indexű művelet ugyanabban a sorrendben fordul elő, mint ahogy a T2 definíciójában szerepelt.
9.2. Konfliktus sorbarendezhetőség
Most egy olyan elégséges feltételt adunk meg, mely biztosítja egy ütemezés sorbarendezhetőségét. A piaci rendszerek ütemezői a tranzakciók sorbarendezhetőségére általában ezt az erősebb feltételt biztosítják, amelyet „konfliktus sorbarendezhetőségnek” nevezünk. Ez a konfliktus (conflict) fogalmon alapul: amely olyan egymást követő műveletpár az ütemezésben, amelynek ha a sorrendjét felcseréljük, akkor legalább az egyik tranzakció viselkedése megváltozhat.
9.2.1. Konfliktusok
Azzal kezdjük, hogy vegyük észre a legtöbb műveletpár nincs konfliktusban a fenti értelemben. Ugyanis, tételezzük fel, hogy Ti és Tj különböző tranzakciók, vagyis i  j.
1.	ri(X); rj(Y) sohasem konfliktus, még akkor sem, ha X = Y. Ennek az az oka, hogy egyik lépés sem változtatja meg az értékeket.
2.	ri(X); wj(Y) nincs konfliktusban, feltéve, ha X  Y. Ennek az az oka, hogy a Tj írhatja az Y-t, mielőtt a Ti beolvasta az X-et, az X értéke ugyanis ettől nem változik. Annak sincs hatása a Tj-re, hogy a Ti olvassa az X-et, ugyanis ez nincs hatással arra, hogy milyen értéket ír be a Tj az Y-ba.
3.	wi(X); rj(Y) nincs konfliktusban, ha X  Y, ugyanazért, mint a 2.
4.	Szintén hasonlóan wi(X); wj(Y) sincs konfliktusban mindaddig, amíg X  Y.

Másrészt három esetben nem cserélhetjük fel a műveletek sorrendjét:
a)	Ugyanannak a tranzakciónak két művelete, pl. ri(X); wi(Y) konfliktus. Ennek az az oka, hogy egyetlen tranzakción belül a műveletek sorrendje rögzített, és az adatbázis-kezelő rendszer ezt a sorrendet nem rendezheti át újra.
b)	Különböző tranzakciók ugyanarra az adatbáziselemre való írása konfliktus. Vagyis wi(X); wj(X) konfliktus. Ennek az az oka, mint már írtuk, hogy az X értéke az marad, amelyet a Tj számolt ki. Ha felcseréljük a sorrendjüket, hogy wj(X); wi(X), akkor az X-nek a Ti által kiszámított értéke marad meg. Az a feltevésünk, hogy „nincs egybeesés”, azt adja, hogy a Ti és a Tj által írt értékek lehetnek különbözőek, és ezért az adatbázis valamelyik kezdeti állapotára különbözni fognak.
c)	Különböző tranzakcióknak ugyanabból az adatbáziselemből való olvasása és írása is konfliktus. Vagyis ri(X); wj(X) konfliktus, és wi(X); rj(X) is konfliktus. Ha átvisszük wj(X)-et ri(X) elé, akkor a Ti által olvasott X-beli érték az lesz, amelyet a Tj írt, amiről pedig feltételeztük, hogy nem szükségképpen egyezik meg az X korábbi értékével. Tehát ri(X) és wj(X) sorrendjének cseréje befolyásolja, hogy Ti milyen értéket olvas X-ből, ez pedig befolyásolja a Ti működését.

Levonhatjuk a következtetést, hogy különböző tranzakciók bármely két műveletének sorrendje felcserélhető, hacsak nem
1.	Ugyanarra az adatbáziselemre vonatkoznak, és
2.	Legalább az egyik művelet írás.

Ezt az elvet kiterjesztve tetszőleges ütemezést véve annyi nem konfliktusos cserét készíthetünk, amennyit csak kívánunk, abból a célból, hogy az ütemezést soros ütemezéssé alakítsuk át. Ha ezt meg tudjuk tenni, akkor az eredeti ütemezés sorba rendezhető volt, ugyanis az adatbázis állapotára való hatása változatlan marad minden nem konfliktusos cserével.
Azt mondjuk, hogy két ütemezés konfliktus ekvivalens (conflict-equivalent), ha szomszédos műveletek nem konfliktusos cseréinek sorozatával az egyiket átalakíthatjuk a másikká. Azt mondjuk, hogy egy ütemezés konfliktus sorbarendezhető (conflict-serializable schedule), ha konfliktus ekvivalens valamely soros ütemezéssel. Megjegyezzük, hogy a konfliktus sorbarendezhetőség elégséges feltétele a sorbarendezhetőségnek, vagyis egy konfliktus sorbarendezhető ütemezés sorba rendezhető ütemezés is egyben. Azonban a konfliktus-sorbarendezhetőség nem szükséges ahhoz, hogy egy ütemezés sorba rendezhető legyen, mégis általában ezt a feltételt ellenőrzik a piaci rendszerek ütemezői, amikor a sorbarendezhetőséget kell biztosítaniuk.
9.6. példa: Legyen az ütemezés
r1(A); w1(A); r2(A); w2(A); r1(B); w1(B); r2(B); w2(B);
a 9.5. példából. Azt állítjuk, hogy ez az ütemezés konfliktus sorbarendezhető. A 9.8. ábrán látható a cserék sorozata, amellyel ez az ütemezés átalakítható a (T1, T2) soros ütemezéssé, ahol az összes T1-beli művelet megelőzi az összes T2-beli műveletet. Aláhúztuk azokat a szomszédos műveletpárokat, amelyeket felcserélünk az egyes lépésekben. 
r1(A); w1(A); r2(A); w2(A); r1(B); w1(B); r2(B); w2(B);
r1(A); w1(A); r2(A); r1(B); w2(A); w1(B); r2(B); w2(B);
r1(A); w1(A); r1(B); r2(A); w2(A); w1(B); r2(B); w2(B);
r1(A); w1(A); r1(B); r2(A); w1(B); w2(A); r2(B); w2(B);
r1(A); w1(A); r1(B); w1(B); r2(A); w2(A); r2(B); w2(B);
9.8. ábra. Egy konfliktus sorbarendezhető ütemezés szomszédos műveletek felcserélésével való átalakítása soros ütemezéssé
9.2.2. Megelőzési gráfok és teszt a konfliktus sorbarendezhetőségre
Viszonylag könnyű megvizsgálnunk egy S ütemezést, és eldöntenünk, hogy konfliktus sorbarendezhető-e vagy nem. Az az alapötlet, hogy ha valahol konfliktusban álló műveletek szerepelnek az S-ben, ezeket a műveleteket végrehajtó tranzakcióknak ugyanabban a sorrendben kell előfordulniuk a konfliktus ekvivalens soros ütemezésekben, mint ahogyan az S-ben voltak. Tehát a konfliktusban álló műveletpárok megszorítást adnak a feltételezett konfliktus ekvivalens soros ütemezésben a tranzakciók sorrendjére. Ha ezek a megszorítások nem mondanak egymásnak ellent, akkor találhatunk konfliktus ekvivalens soros ütemezést. Ha pedig ellentmondanak egymásnak, akkor tudjuk, hogy nincs ilyen soros ütemezés.
Adott a T1 és T2 tranzakcióknak, esetleg további tranzakcióknak, egy S ütemezése. Azt mondjuk, hogy T1 megelőzi T2-t, és T1 <S T2-vel jelöljük, ha van a T1-ben olyan A1 művelet, és a T2-ben olyan A2, hogy
1.	A1 megelőzi A2-t az S-ben,
2.	A1 és A2 ugyanarra az adatbáziselemre vonatkoznak, és
3.	A1 és A2 közül legalább az egyik írás művelet.
Megjegyezzük, hogy ezek pontosan azok a feltételek, amikor nem lehet felcserélni az A1 és A2 sorrendjét. Tehát, A1 az A2 előtt szerepel bármely az S-sel konfliktus ekvivalens ütemezésben. Ennek eredményeként, ha ezek közül az ütemezések közül az egyik soros ütemezés, akkor ebben T1-nek meg kell előznie T2-t.
Ezeket a megelőzéseket a megelőzési gráfban (precedence graph) összegezhetjük. A megelőzési gráf csomópontjai az S ütemezés tranzakciói. Ha a tranzakciókat Ti-vel jelöljük az i függvényében, akkor a Ti-nek megfelelő csomópontot az i egésszel jelöljük. Az i csomópontból a j csomópontba vezet irányított él, ha Ti <S Tj.
9.7. példa: A következő S ütemezés a T1, T2, T3 három tranzakciót tartalmazza:
S: r2(A); r1(B); w2(A); r3(A); w1(B); w3(A); r2(B); w2(B);
Ha az A-val kapcsolatos műveleteket nézzük meg, akkor több okot találunk, hogy miért igaz a T2 <S T3. Például r2(A) az S-ben w3(A) előtt áll, és w2(A) az r3(A) és a w3(A) előtt is áll. A három észrevételünk közül bármelyik elegendő, hogy igazoljuk, valóban vezet él a 2-ből 3-ba a 9.9. ábrán szereplő megelőzési gráfban.





9.9. ábra. A 9.7. példa S ütemezéséhez tartozó megelőzési gráf

Hasonló módon ha megnézzük a B-vel kapcsolatos műveleteket, akkor szintén több okot találunk, hogy miért igaz a T1 <S T2. Például r1(B) művelet a w2(B) művelet előtt áll. Tehát az S megelőzési gráfjában az 1-ből 2-be szintén vezet él. Tulajdonképpen ezek és csak ezek az élek azok, amelyeket az S ütemezésben szereplő műveletek sorrendjéből tudunk ellenőrizni. 

Van egy egyszerű szabály, amivel megmondhatjuk, hogy egy S ütemezés konfliktus sorbarendezhető-e:
•	Rajzoljuk fel az S megelőzési gráfját, és nézzük meg tartalmaz-e kört!
Ha igen, akkor S nem konfliktus sorbarendezhető. Ha pedig a gráf körmentes, akkor S konfliktus sorbarendezhető, továbbá a csomópontok bármelyik topologikus sorrendje  megadja a konfliktus ekvivalens soros sorrendet.
9.8. példa: A 9.9. ábra megelőzési gráfja körmentes, így a 9.7. példa S ütemezése konfliktus-sorbarendezhető. A csomópontoknak, azaz a tranzakcióknak csak egyetlen sorrendje van, amely konzisztens a gráf éleivel, és ez: (T1, T2, T3). Megjegyezzük, hogy az S-et valóban át lehet alakítani olyan ütemezéssé, amelyben a három tranzakció mindegyikének az összes művelete ugyanebben a sorrendben van, és ez a soros ütemezés:
Miért nem szükséges konfliktus sorbarendezhetőség a sorbarendezhetőséghez?
Egy példát már láttunk a 9.7. ábrán. Akkor megnéztük, hogy a T2 által végrehajtott speciális számítások miatt hogyan vált az ütemezés sorba rendezhetővé. Pedig a 9.7. ábra ütemezése nem konfliktus sorbarendezhető, ugyanis az A-t T1 írja előbb, a B-t pedig a T2. Mivel sem az A írását, sem a B írását nem lehet átrendezni, semmilyen módon nem kerülhet T1 összes művelete a T2 összes művelete elé, sem fordítva.
Azonban vannak olyan sorba rendezhető, de nem konfliktus sorbarendezhető ütemezések is, amelyek nem függnek a tranzakciók által végrehajtott számításoktól. Például tekintsük a T1, T2, és T3 három tranzakciót, amelyek mindegyike X értékét írja. A T1 és T2 az Y-nak is ír értéket, mielőtt az X-nek írnának értéket. Az egyik lehetséges ütemezés, amely itt éppen soros is, a következő:

S1: w1(Y); w1(X); w2(Y); w2(X); w3(X).

Az S1 ütemezés X értékének a T3 által írt értéket, Y értékének pedig a T2 által írt értéket adja. Ugyanezt végzi a következő ütemezés is:

S2: w1(Y); w2(Y); w2(X); w1(X); w3(X).

Intuíció alapján átgondolva annak, hogy a T1 és a T2 milyen értéket ír az X-be, nincs hatása, ugyanis a T3 felülírja az értékeket. Emiatt S1 és S2 az X-nek is és az Y-nak is ugyanazt az értéket adja. Mivel az S1 soros, és az S2-nek bármely adatbázis-állapotra ugyanaz a hatása, mint az S1-nek, tehát S2 sorba rendezhető. Ugyanakkor mivel nem tudjuk felcserélni w1(Y)-t w2(Y)-nal, és nem tudjuk felcserélni w1(X)-et w2(X)-szel, így cseréken keresztül nem lehet az S2-t valamelyik soros ütemezéssé átalakítani. Tehát S2 sorba rendezhető, de nem konfliktus sorbarendezhető.
S: r1(B); w1(B); r2(A); w2(A); r2(B); w2(B); r3(A); w3(A);
Ahhoz, hogy belássuk, megkaphatjuk az S-ből az S-t szomszédos elemek cseréjével, az első észrevételünk, hogy az r1(B)-t konfliktus nélkül az r2(A) elé hozhatjuk. Ezután három cserével a w1(B)-t közvetlenül az r1(B) utánra tudjuk cserélni, ugyanis mindegyik közbeeső művelet az A-ra vonatkozik, és a B-re nem. Ezután az r2(B)-t és a w2(B)-t csak az A-ra vonatkozó műveleteken keresztül át tudjuk vinni pontosan a w2(A) utáni helyzetbe, amivel megkapjuk az S-t. 
9.9. példa: Tekintsük az alábbi ütemezést:

S1: r2(A); r1(B); w2(A); r2(B); r3(A); w1(B); w3(A); w2(B);

amely csak abban különbözik az S-től, hogy az r2(B) művelet három hellyel előbb szerepel. Az A-ra vonatkozó műveleteket megvizsgálva most is csak a T2 <S1 T3 megelőzési kapcsolathoz jutunk. De, ha a B-t vizsgáljuk, akkor nemcsak T1 < S1 T2 teljesül (ugyanis r1(B) és w1(B) a w2(B) előtt szerepel), hanem T2 < S1 T1 is (ugyanis r2(B) a w1(B) előtt fordul elő). Emiatt az S1 ütemezéshez tartozó megelőzési gráf az, amely a 9.10. ábrán látható.

9.10. ábra. A 9.9. példa S1 ütemezéséhez tartozó ciklikus megelőzési gráf,
ez az ütemezés nem konfliktus sorbarendezhető
Ez a gráf nyilvánvalóan tartalmaz kört. Arra következtethetünk, hogy S1 nem konfliktus sorbarendezhető, ugyanis intuíció alapján láthatjuk, hogy bármely konfliktus ekviva¬lens soros ütemezésben a T1-nek T2 előtt is és után is kellene állnia, így emiatt nem létezik ilyen ütemezés. 

9.2.3. Miért működik a megelőzési gráfon alapuló tesztelés?
Láttuk, hogy a megelőzési gráfban a kör túl sok megszorítást jelent a feltételezett kon¬flik¬tusekvivalens soros ütemezésre nézve. Azaz, ha létezik T1  T2    Tn  T1 n darab tranzakcióból álló kör, akkor a feltételezett soros sorrendben T1 mű¬ve¬leteinek meg kell előznie a T2-ben szereplő műveleteket, amelyek megelőzik a T3-belieket és így tovább egészen Tn-ig. De a Tn műveletei emiatt a T1-beliek mögött vannak, ugyanakkor meg is kellene előzniük a T1-belieket a Tn  T1 él miatt. Ebből következik, hogyha a megelőzési gráf tartalmaz kört, akkor az ütemezés nem konfliktus¬-sor¬ba¬rendezhető.
A másik irányt egy kicsit nehezebb belátnunk. Azt kell megmutatnunk, hogy amikor a megelőzési gráf körmentes, akkor az ütemezés műveletei átrendezhetők szomszédos műveletek szabályos cseréivel úgy, hogy az ütemezés egy soros ütemezéssé váljon. Ha ezt meg tudjuk tenni, akkor bebizonyítottuk, hogy minden körmentes megelőzési gráffal rendelkező ütemezés egyben konfliktus-sorbarendezhető. A bizonyítás az ütemezésben részt vevő tranzakciók száma szerinti indukcióval történik.
Alapeset: Ha n = 1, vagyis csak egyetlen tranzakcióból áll az ütemezés, akkor az ütemezés már önmagában soros, emiatt biztosan konfliktus-sorbarendezhető.
Indukció: Legyen S

T1, T2, …, Tn
n darab tranzakció műveleteiből álló ütemezés. Tételezzük fel, hogy S-nek körmentes megelőzési gráfja van. Ha a véges gráf körmentes, akkor van legalább egy olyan csomópontja, amelybe nem vezet él. Legyen a Ti tranzakciónak megfelelő i csomópont egy ilyen csomópont. Mivel nem vezet az i csomópontba él, nincs az S-ben olyan A művelet, hogy:
1.	Valamelyik Tj, a Ti-től különböző tranzakcióra vonatkozzon,
2.	Ti valamely műveletét megelőzi, és
3.	Ezzel a művelettel konfliktusban van.

Ugyanis, ha lenne ilyen, akkor a megelőzési gráfban be kellene rajzolnunk egy élt a j csomópontból az i csomópontba.
Így lehetséges, hogy a Ti minden műveletét az S legelejére mozgatjuk át, miközben megtartjuk a sorrendjüket. Az ütemezés most a következő alakú:

(Ti műveletei) (a többi n – 1 tranzakció műveletei)

Most tekintsük az S második részét, vagyis a Ti-től különböző összes tranzakciónak a műveleteit. Mivel ezek a műveletek egymáshoz viszonyítva ugyanabban a sorrendben vannak, mint ahogyan az S-ben voltak, ennek a második résznek a megelőzési gráfja megegyezik az S olyan megelőzési gráfjával, amelyből elhagyjuk a Ti csomópontot és az ebből a csomópontból kimenő éleket.
Mivel az eredeti megelőzési gráf körmentes volt, és csomópontok, illetve élek törlésével nem válhatott ciklikussá, következik, hogy a második rész megelőzési gráfja is körmentes. Továbbá, mivel a második része n – 1 tranzakciót tartalmaz, alkalmazzuk rá az indukciós feltevést. Így tudjuk, hogy a második rész műveletei szomszédos műveletek szabályos cseréivel átrendezhetők soros ütemezéssé. Ily módon magát az S-et alakítottuk át olyan soros ütemezéssé, amelyben a Ti műveletei állnak legelöl, és a többi tranzakció műveletei ezután következnek valamilyen soros sorrendben. Az indukciót beláttuk, és így következik, hogy minden olyan ütemezés, amelynek körmentes a megelőzési gráfja, egyben konfliktus-sorbarendezhető.
</body>
</html>